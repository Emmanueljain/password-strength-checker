<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Password Strength Checker üîê</title>
  <style>
    :root{
      --bg-1: #0f172a; /* dark */
      --bg-2: #020617;
      --panel: rgba(15, 23, 42, 0.92);
      --muted: #94a3b8;
      --glass-shadow: 0 0 20px rgba(59, 130, 246, 0.25);
    }
    html,body{height:100%;margin:0;}
    body {
      font-family: 'Poppins', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: radial-gradient(circle at top left, var(--bg-1), var(--bg-2));
      color: #e2e8f0;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      overflow: hidden;
      position: relative;
    }

    /* Matrix canvas sits behind everything */
    #matrix {
      position: fixed;
      inset: 0;
      z-index: 0;
      pointer-events: none; /* don't block clicks */
      opacity: 0.22; /* subtle by default */
      transition: opacity 0.3s ease, filter 0.3s ease;
      filter: blur(0.2px) saturate(0.9);
    }
    /* intensify when active */
    #matrix.active { opacity: 0.9; filter: blur(0px) saturate(1.1); }

    /* faint grid overlay for nice texture (keeps original feel) */
    body::before {
      content: "";
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background-image: linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
                        linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
      background-size: 20px 20px;
      z-index: 0;
      pointer-events: none;
    }

    .wrap {
      position: relative;
      z-index: 2; /* above canvas */
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 18px;
      width: 360px;
    }

    .container {
      background-color: var(--panel);
      box-shadow: var(--glass-shadow);
      border-radius: 14px;
      padding: 30px 32px;
      text-align: center;
      width: 100%;
      transition: transform 0.25s ease, box-shadow 0.25s ease;
      border: 1px solid rgba(255,255,255,0.03);
    }

    .container:hover { transform: translateY(-3px); box-shadow: 0 10px 40px rgba(10, 60, 160, 0.14); }

    h2 { margin:0 0 12px 0; font-size:20px; letter-spacing:0.2px; }
    input {
      padding: 12px;
      font-size: 15px;
      width: 100%;
      border: 2px solid rgba(203,213,225,0.06);
      border-radius: 8px;
      outline: none;
      color: #e2e8f0;
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(255,255,255,0.00));
      transition: 0.2s;
      caret-color: #60a5fa;
    }
    input::placeholder { color: #94a3b8; opacity: 0.8; }
    input:focus { border-color: #2563eb; box-shadow: 0 0 6px rgba(37,99,235,0.12); }

    .strength { margin-top: 12px; height: 10px; width: 100%; background-color: rgba(226,232,240,0.06); border-radius: 6px; overflow: hidden; }
    .strength-bar { height:100%; width:0%; background:linear-gradient(90deg,#ef4444,#f97316); border-radius:6px; transition: width 0.45s ease, background 0.45s ease; }

    #message { margin-top:10px; font-weight:600; color:#cbd5e1; font-size:13px; min-height:18px; }

    .footer { margin-top:6px; font-size:12px; color:var(--muted); text-align:center; }

    /* terminal / hacker log */
    .hacker-log {
      width: 100%;
      background: rgba(2,6,23,0.5);
      border-radius: 8px;
      padding: 10px 12px;
      color: #6ee7b7;
      font-family: "Source Code Pro", ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace;
      font-size: 12px;
      text-align: left;
      min-height: 58px;
      border: 1px solid rgba(110,231,183,0.06);
      box-shadow: inset 0 0 12px rgba(0,0,0,0.3);
      overflow: hidden;
    }
    .hacker-line { white-space: nowrap; display:block; line-height:1.3; }
    .muted { color: #94a3b8; font-weight:400; }

    /* small responsive tweak */
    @media (max-width:420px){
      .wrap { width:92%; }
    }
  </style>
</head>
<body>
  <!-- Canvas for matrix effect -->
  <canvas id="matrix"></canvas>

  <div class="wrap">
    <div class="container">
      <h2>Password Strength Checker üîí</h2>
      <input type="password" id="password" placeholder="Enter your password" autocomplete="new-password" />
      <div class="strength"><div class="strength-bar" id="strength-bar"></div></div>
      <p id="message"></p>
    </div>

    <div class="hacker-log" id="hacker-log" aria-live="polite">
      <span class="hacker-line muted">Waiting for input...</span>
    </div>

    <div class="footer">Made with üíª by <strong>You</strong></div>
  </div>

  <script>
    /* === Password strength logic (unchanged except small improvements) === */
    const password = document.getElementById("password");
    const bar = document.getElementById("strength-bar");
    const message = document.getElementById("message");

    function evaluate(val) {
      let strength = 0;
      if (val.length >= 8) strength++;
      if (/[A-Z]/.test(val) && /[a-z]/.test(val)) strength++;
      if (/[0-9]/.test(val)) strength++;
      if (/[^A-Za-z0-9]/.test(val)) strength++;
      if (val.length >= 12) strength++;
      return strength;
    }

    const colors = ["#ef4444", "#f97316", "#facc15", "#22c55e", "#16a34a"];
    const levels = ["Very Weak", "Weak", "Medium", "Strong", "Very Strong"];

    password.addEventListener("input", () => {
      const val = password.value;
      const s = evaluate(val);
      bar.style.width = (s * 20) + "%";
      bar.style.background = colors[s - 1] || "transparent";
      message.textContent = val ? (levels[s - 1] || "") : "";
      // update hacker log
      hackerStimulate(val);
      // intensify canvas when typing
      toggleMatrixActive(!!val);
    });

    password.addEventListener("focus", ()=> toggleMatrixActive(true));
    password.addEventListener("blur", ()=> toggleMatrixActive(!!password.value));

    /* === Matrix background (canvas) === */
    const canvas = document.getElementById("matrix");
    const ctx = canvas.getContext("2d");
    let width, height, columns, drops, fontSize = 15;
    const charset = "01ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz$%&*+-/#@<>";

    function resize() {
      width = canvas.width = innerWidth;
      height = canvas.height = innerHeight;
      columns = Math.floor(width / fontSize) + 1;
      drops = new Array(columns).fill(0).map(()=> Math.floor(Math.random()*height/fontSize));
    }
    window.addEventListener("resize", resize);
    resize();

    let baseSpeed = 0.6;        // base drop speed
    let activeMultiplier = 3.0; // when active (typing/focused)
    let globalAlpha = 0.075;    // trail length / persistence

    function drawMatrix(active=false) {
      // fade background slightly to produce trail
      ctx.fillStyle = `rgba(0, 0, 0, ${globalAlpha})`;
      ctx.fillRect(0, 0, width, height);

      ctx.font = `${fontSize}px monospace`;
      // flickering green gradient for characters
      const grad = ctx.createLinearGradient(0, 0, 0, height);
      grad.addColorStop(0, '#b7f5c8'); // light green
      grad.addColorStop(0.5, '#34d399');
      grad.addColorStop(1, '#065f46');

      ctx.fillStyle = grad;
      const speed = baseSpeed * (active ? activeMultiplier : 1.0);

      for (let i = 0; i < columns; i++) {
        const text = charset.charAt(Math.floor(Math.random() * charset.length));
        const x = i * fontSize;
        const y = drops[i] * fontSize;
        // Occasionally draw a brighter char as a head
        if (Math.random() > 0.92) {
          ctx.fillStyle = '#e6fffa';
          ctx.fillText(text, x, y);
          ctx.fillStyle = grad;
        } else {
          ctx.fillText(text, x, y);
        }
        // advance drop
        drops[i] = drops[i] + (Math.random() * speed);
        // random reset when out of view
        if (drops[i] * fontSize > height && Math.random() > 0.975) {
          drops[i] = 0;
        }
      }
      // run again
      requestAnimationFrame(()=> drawMatrix(active));
    }

    // run initially with not active; we will trigger active state by toggling canvas class and speeds
    let matrixActive = false;
    function toggleMatrixActive(on) {
      matrixActive = !!on;
      canvas.classList.toggle('active', matrixActive);
      // start drawing with the correct active flag
      // (drawMatrix is looped so just set a flag; to keep it simple we call drawMatrix once more)
      // We pass the matrixActive variable down ‚Äî drawMatrix reads it each loop.
      // For simplicity we implement drawMatrix to always re-schedule itself; we kick it once.
    }

    // Kick off the animation loop using current matrixActive flag
    (function loop() {
      // use a closure variable to read matrixActive each frame
      function step() {
        drawMatrix(matrixActive);
        setTimeout(()=> requestAnimationFrame(step), 0); // keep steady
      }
      step();
    })();

    /* === Hacker log (typing / fake scan messages) === */
    const hackerLog = document.getElementById('hacker-log');

    const messages = [
      "Initializing entropy analysis...",
      "Scanning character sets...",
      "Brute-force timeline estimation: calculating...",
      "Checking for common password patterns...",
      "Comparing against leaked database hashes...",
      "Estimating crack difficulty...",
      "Applying password heuristics...",
      "Entropy score computed."
    ];

    let logTimeouts = [];

    function clearLogTimers() {
      logTimeouts.forEach(t => clearTimeout(t));
      logTimeouts = [];
    }

    function typeLine(text, container, delay = 0, speed = 30) {
      return new Promise(resolve => {
        const line = document.createElement('span');
        line.className = 'hacker-line';
        container.appendChild(line);
        let i = 0;
        function step() {
          if (i <= text.length) {
            line.textContent = text.slice(0, i) + (i % 2 ? '_' : ''); // blinking caret effect while typing
            i++;
            setTimeout(step, speed);
          } else {
            line.textContent = text; // finalize
            resolve();
          }
        }
        setTimeout(step, delay);
      });
    }

    async function hackerStimulate(currentValue) {
      clearLogTimers();
      hackerLog.innerHTML = ''; // reset lines quickly
      if (!currentValue) {
        const el = document.createElement('span');
        el.className = 'hacker-line muted';
        el.textContent = 'Waiting for input...';
        hackerLog.appendChild(el);
        return;
      }

      // when user types, show 2-4 messages chosen pseudo-randomly
      const count = Math.min(4, 2 + Math.floor(currentValue.length / 4));
      const chosen = [];
      for (let i = 0; i < count; i++) {
        chosen.push(messages[(Math.floor(Math.random() * messages.length))]);
      }
      // staged typing
      let delay = 100;
      for (let i = 0; i < chosen.length; i++) {
        const d = delay + i*450;
        // schedule typing
        const t = setTimeout(() => {
          // fade canvas more while messages are typing
          canvas.classList.add('active');
          typeLine(">> " + chosen[i], hackerLog, 0, 22).then(()=>{
            // remove active state a bit later if input empty
            if (!password.value) canvas.classList.remove('active');
          });
        }, d);
        logTimeouts.push(t);
      }
      // final summary line after a bit
      const finalDelay = delay + chosen.length * 450 + 200;
      const t2 = setTimeout(()=> {
        const strength = evaluate(currentValue);
        const lvl = ["Very Weak","Weak","Medium","Strong","Very Strong"][strength-1] || "Unknown";
        typeLine(`>> Analysis: ${lvl} (${strength}/5)`, hackerLog, 0, 18);
      }, finalDelay);
      logTimeouts.push(t2);

      // subtle self-remove 'active' after a while if user stopped typing
      const t3 = setTimeout(() => {
        if (!password.matches(':focus')) canvas.classList.remove('active');
      }, finalDelay + 1400);
      logTimeouts.push(t3);
    }

    // initialize log
    hackerStimulate('');

    // a tiny improvement: on load focus none
    window.addEventListener('load', ()=> {
      // keep matrix subtle initially
      toggleMatrixActive(false);
    });
  </script>
</body>
</html>
